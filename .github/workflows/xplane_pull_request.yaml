name: üì¶ Crossplane Package Pipeline

on:
  workflow_call:
    inputs:
      CROSSPLANE_PACKAGES_DIR:
        required: true
        type: string
        description: "Directory containing Crossplane packages"

      CROSSPLANE_REGISTRY_URL:
        required: true
        type: string
        description: "URL of the container registry for Crossplane packages"

      SUBPATH:
        required: true
        type: string
        description: "Composition subpath to package"

      NEXT_VERSION:
        required: true
        type: string
        description: "Version tag for the package"

    secrets:
      REGISTRY_USERNAME:
        description: "Username for container registry to login"
        required: true

      REGISTRY_PASSWORD:
        description: "Password for container registry to login"
        required: true

jobs:
  # Package crossplane composition
  package-composition:
    name: üì¶ Package Crossplane Composition
    runs-on: ubuntu-latest

    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: '0'

      - name: üîë Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.CROSSPLANE_REGISTRY_URL }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: üõ†Ô∏è Setup Crossplane CLI
        run: |
          curl -sL https://raw.githubusercontent.com/crossplane/crossplane/master/install.sh | sh
          sudo mv crossplane /usr/local/bin/

      - name: ‚úÖ Validate and Prepare
        working-directory: ${{ inputs.CROSSPLANE_PACKAGES_DIR }}
        run: |
          echo "üîç Preparing package for ${{ inputs.SUBPATH }}"
          # Set up temp file paths
          BUILD_OUTPUT="${{ runner.temp }}/build_output.log"
          SUMMARY_LINES="${{ runner.temp }}/summary_lines.log"

          # Run make all and display output in real-time
          set -o pipefail  # Ensure the pipeline returns non-zero if make fails
          make all PACKAGE_NAME=${{ inputs.SUBPATH }} 2>&1 | tee "$BUILD_OUTPUT"

          # Debug - print file size
          echo "üìã Debug: Build output file size: $(wc -c "$BUILD_OUTPUT" | awk '{print $1}') bytes"

          # Debug - print last 200 lines for examination
          echo "üìã Debug: Last 200 lines of build output:"
          tail -n 200 "$BUILD_OUTPUT"

          # Extract all lines containing 'Total' for a broader search
          echo "üìã Debug: Extracting all lines with 'Total'"
          grep "Total" "$BUILD_OUTPUT" > "$SUMMARY_LINES" || echo "No 'Total' lines found"
          echo "Summary lines content:"
          cat "$SUMMARY_LINES"

          # Look directly for failure patterns with different approaches
          echo "üìã Debug: Searching for 'failure cases' (case insensitive)"
          grep -i "failure cases" "$BUILD_OUTPUT" || echo "No 'failure cases' found"

          echo "üìã Debug: Searching for lines with [x] indicating errors"
          grep "\\[x\\]" "$BUILD_OUTPUT" || echo "No [x] lines found"

          # Try different grep options that might be more lenient
          echo "üìã Debug: Searching with -F flag (fixed strings)"
          grep -F "failure cases" "$BUILD_OUTPUT" || echo "No fixed string matches"

          echo "üìã Debug: Searching with word boundaries"
          grep -w "failure" "$BUILD_OUTPUT" || echo "No 'failure' word found"

          # Look for failure indicators more broadly
          if grep -q "failure cases" "$BUILD_OUTPUT"; then
            echo "‚ùå Found potential validation failures:"
            grep -B2 -A2 "failure cases" "$BUILD_OUTPUT"

            # Extract all lines with counts of failure cases > 0
            if grep -E "[1-9][0-9]* failure cases" "$BUILD_OUTPUT"; then
              echo "‚ùå Validation failed! Found lines with non-zero failure cases"
              exit 1
            fi
          fi

          # Count total number of [x] lines which indicate failures
          FAILURE_COUNT=$(grep -c "\\[x\\]" "$BUILD_OUTPUT" || echo "0")
          if [ "$FAILURE_COUNT" -gt 0 ]; then
            echo "‚ùå Validation failed! Found $FAILURE_COUNT validation errors in the output"
            grep "\\[x\\]" "$BUILD_OUTPUT"
            exit 1
          fi

          # Final fallback - write the entire build output to a GitHub Actions artifact for inspection
          echo "DEBUG: Saving build output for inspection"
          mkdir -p ./debug-artifacts
          cp "$BUILD_OUTPUT" ./debug-artifacts/build_output.log

          echo "‚úÖ Validation completed successfully"

      - name: üì¶ Create Package
        working-directory: ${{ inputs.CROSSPLANE_PACKAGES_DIR }}
        run: |
          echo "üì¶ Packaging ${{ inputs.SUBPATH }} version ${{ inputs.NEXT_VERSION }}"
          # Create package directory if it doesn't exist
          mkdir -p ${{ inputs.SUBPATH }}/package
          crossplane xpkg build --package-root=${{ inputs.SUBPATH }}/configuration -o ${{ inputs.SUBPATH }}/package/${{ inputs.SUBPATH }}-${{ inputs.NEXT_VERSION }}.xpkg

      - name: üì§ Upload Package Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.SUBPATH }}-package
          path: ${{ inputs.CROSSPLANE_PACKAGES_DIR }}/${{ inputs.SUBPATH }}/package/${{ inputs.SUBPATH }}-${{ inputs.NEXT_VERSION }}.xpkg
          if-no-files-found: error
          retention-days: 1

  # publish crossplane package
  publish-package:
    name: üì° Publish Crossplane Package
    runs-on: ubuntu-latest
    needs:
      - package-composition
    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4

      - name: üì• Download Package Artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.SUBPATH }}-package
          path: ./artifacts

      - name: üõ†Ô∏è Setup Crossplane CLI
        run: "curl -sL https://raw.githubusercontent.com/crossplane/crossplane/master/install.sh | sh"

      - name: üîë Login to Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.CROSSPLANE_REGISTRY_URL }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: üöÄ Push Package to Registry
        run: |
          echo "üì° Publishing ${{ inputs.SUBPATH }} version ${{ inputs.NEXT_VERSION }} to registry"
          ./crossplane --verbose xpkg push -f ./artifacts/${{ inputs.SUBPATH }}-${{ inputs.NEXT_VERSION }}.xpkg ${{ inputs.CROSSPLANE_REGISTRY_URL }}/${{ inputs.SUBPATH }}:${{ inputs.NEXT_VERSION }}

      - name: üè∑Ô∏è Create and Push Git Tag
        if: ${{ !contains(inputs.NEXT_VERSION, '-pr') }}
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ inputs.SUBPATH }}/${{ inputs.NEXT_VERSION }}" -m "Release ${{ inputs.SUBPATH }}/v${{ inputs.NEXT_VERSION }}"
          git push origin "${{ inputs.SUBPATH }}/${{ inputs.NEXT_VERSION }}"

      - name: ‚ú® Summary
        run: |
          echo "‚úÖ Successfully published ${{ inputs.SUBPATH }} version ${{ inputs.NEXT_VERSION }} to ${{ inputs.CROSSPLANE_REGISTRY_URL }}"
          echo "‚úÖ Created and pushed git tag ${{ inputs.SUBPATH }}/${{ inputs.NEXT_VERSION }}"
